@using MudBlazor
@using Mythetech.Framework.Infrastructure.Secrets
@inherits MudComponentBase
@implements IDisposable

<MudTextField Value="@_value"
              ValueChanged="@(async(s) => await OnValueChanged(s))"
              InputType="@(string.IsNullOrEmpty(_value) ? InputType.Text : InputType.Password)"
              UserAttributes="@GetTextFieldAttributes()"
              Adornment="Adornment.End"
              AdornmentIcon="@Icons.Material.Rounded.Key"
              T="string"
              OnAdornmentClick="@TogglePopover">
</MudTextField>

<MudPopover Open="@_popoverOpen" AnchorOrigin="Origin.BottomCenter" TransformOrigin="Origin.TopCenter">
    <MudAutocomplete T="Secret"
                     Value="_selectedSecret"
                     ValueChanged="OnSecretSelected"
                     SearchFunc="@SearchSecrets"
                     ToStringFunc="@(secret => secret?.Name ?? secret?.Key ?? string.Empty)"
                     Label="Select Secret"
                     Variant="Variant.Outlined"
                     Dense="true"
                     MaxItems="10"
                     Adornment="Adornment.Start"
                     AdornmentIcon="@Icons.Material.Filled.Search"
                     Class="ma-2"
                     Style="min-width: 300px;">
        <ItemTemplate>
            <MudStack Spacing="1">
                <MudText Typo="Typo.body2">@context.Name</MudText>
                @if (!string.IsNullOrEmpty(context.Description))
                {
                    <MudText Typo="Typo.caption" Color="Color.Secondary">@context.Description</MudText>
                }
                <MudText Typo="Typo.caption" Color="Color.Secondary">@context.Key</MudText>
            </MudStack>
        </ItemTemplate>
    </MudAutocomplete>
</MudPopover>

@code {
    [Inject]
    private SecretManagerState? SecretManagerState { get; set; }
    
    [Parameter]
    public string? Value { get; set; }
    
    [Parameter]
    public EventCallback<string?> ValueChanged { get; set; }
    
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }
    
    private string? _value;
    private Secret? _selectedSecret;
    private bool _popoverOpen;
    
    protected override void OnInitialized()
    {
        _value = Value;
        if (SecretManagerState != null)
        {
            SecretManagerState.StateChanged += OnStateChanged;
        }
    }
    
    protected override void OnParametersSet()
    {
        if (Value != _value)
        {
            _value = Value;
        }
    }
    
    private void OnStateChanged(object? sender, EventArgs e)
    {
        InvokeAsync(StateHasChanged).ContinueWith(t =>
        {
            if (t.IsFaulted && t.Exception != null)
            {
                Console.Error.WriteLine($"Error in OnStateChanged: {t.Exception}");
            }
        }, TaskScheduler.Default);
    }
    
    private async Task OnValueChanged(string? newValue)
    {
        _value = newValue;
        await ValueChanged.InvokeAsync(newValue);
    }
    
    private void TogglePopover()
    {
        _popoverOpen = !_popoverOpen;
    }
    
    private async Task<IEnumerable<Secret>> SearchSecrets(string value, CancellationToken token)
    {
        if (SecretManagerState == null)
        {
            return [];
        }
        
        if (string.IsNullOrWhiteSpace(value))
        {
            return SecretManagerState.Secrets;
        }
        
        return await SecretManagerState.SearchSecretsAsync(value);
    }
    
    private async Task OnSecretSelected(Secret? secret)
    {
        if (secret != null && SecretManagerState != null)
        {
            var result = await SecretManagerState.GetSecretAsync(secret.Key);
            if (result.Success && result.Value != null)
            {
                _selectedSecret = result.Value;
                _value = result.Value.Value;
                await ValueChanged.InvokeAsync(_value);
                _popoverOpen = false;
                StateHasChanged();
            }
        }
    }
    
    private Dictionary<string, object> GetTextFieldAttributes()
    {
        var attrs = new Dictionary<string, object>();
        
        if (AdditionalAttributes != null)
        {
            foreach (var attr in AdditionalAttributes)
            {
                attrs[attr.Key] = attr.Value;
            }
        }
        
        return attrs;
    }
    
    public void Dispose()
    {
        if (SecretManagerState != null)
        {
            SecretManagerState.StateChanged -= OnStateChanged;
        }
    }
}

