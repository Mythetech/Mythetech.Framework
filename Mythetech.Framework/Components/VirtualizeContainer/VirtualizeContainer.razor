@using Microsoft.AspNetCore.Components.Web.Virtualization
@using MudBlazor.Interop
@using MudBlazor.Services
@namespace Mythetech.Framework.Components.VirtualizeContainer
@typeparam TItem
@implements IAsyncDisposable

<div @ref="_containerRef" class="@ContainerClass" style="@Style">
    @if (_containerSize > 0)
    {
        <Virtualize TItem="TItem" Items="@Items" Context="item" ItemSize="@ItemSize" OverscanCount="@OverscanCount">
            @ChildContent(item)
        </Virtualize>
    }
</div>

@code {
    [Inject] private IResizeObserverFactory ResizeObserverFactory { get; set; } = default!;

    /// <summary>
    /// The collection of items to virtualize.
    /// </summary>
    [Parameter, EditorRequired]
    public ICollection<TItem> Items { get; set; } = default!;

    /// <summary>
    /// The template for rendering each item.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment<TItem> ChildContent { get; set; } = default!;

    /// <summary>
    /// The fixed size (height for vertical, width for horizontal) of each item in pixels.
    /// </summary>
    [Parameter]
    public float ItemSize { get; set; } = 32;

    /// <summary>
    /// The number of additional items to render outside the visible area.
    /// </summary>
    [Parameter]
    public int OverscanCount { get; set; } = 3;

    /// <summary>
    /// Orientation of the virtualized list. Defaults to Vertical.
    /// Note: Horizontal orientation is experimental - the underlying Blazor Virtualize component
    /// only supports vertical virtualization, so horizontal mode renders all items without virtualization.
    /// </summary>
    [Parameter]
    public Orientation Orientation { get; set; } = Orientation.Vertical;

    /// <summary>
    /// Additional CSS class(es) to apply to the container.
    /// </summary>
    [Parameter]
    public string? Class { get; set; }

    /// <summary>
    /// Additional inline styles to apply to the container.
    /// </summary>
    [Parameter]
    public string? Style { get; set; }

    private ElementReference _containerRef;
    private IResizeObserver? _resizeObserver;
    private double _containerSize;

    private bool IsHorizontal => Orientation == Orientation.Horizontal;

    private string ContainerClass => IsHorizontal
        ? $"mf-virtualize-container mf-virtualize-container--horizontal {Class}"
        : $"mf-virtualize-container mf-virtualize-container--vertical {Class}";

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _resizeObserver = ResizeObserverFactory.Create();
            _resizeObserver.OnResized += OnResized;
            var rect = await _resizeObserver.Observe(_containerRef);

            _containerSize = IsHorizontal ? rect?.Width ?? 0 : rect?.Height ?? 0;
            if (_containerSize > 0)
            {
                StateHasChanged();
            }
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    private void OnResized(IDictionary<ElementReference, BoundingClientRect> changes)
    {
        if (changes.TryGetValue(_containerRef, out var rect))
        {
            var newSize = IsHorizontal ? rect.Width : rect.Height;
            if (Math.Abs(_containerSize - newSize) > 1)
            {
                _containerSize = newSize;
                StateHasChanged();
            }
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_resizeObserver != null)
        {
            _resizeObserver.OnResized -= OnResized;
            await _resizeObserver.DisposeAsync();
        }
    }
}