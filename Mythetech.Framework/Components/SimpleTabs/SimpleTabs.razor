@using MudBlazor
@using MudBlazor.Interop
@using MudBlazor.Services
@inherits MudComponentBase
@implements IAsyncDisposable
@inject IResizeObserver ResizeObserver

<CascadingValue Value="this">
    @ChildContent
</CascadingValue>

<MudStack Class="mud-width-full mud-height-full">
    <div @ref="_tabBarRef" class="@WrapperClass">
        <MudStack Row="true" Justify="Justify.Center" Class="@($"pa-1 align-text-center rounded {GetBorderClass(Color)} {Class}")" Spacing="0" AlignItems="AlignItems.Center" Style="@Style">
        @if (_isCompactMode)
        {
            @* Compact mode: show active tab + overflow menu *@
            var activeTab = _tabs.FirstOrDefault(t => t.IsActive);
            if (activeTab != null)
            {
                <MudLink Class="@($"flex-grow-1 rounded {GetBackgroundClass(Color)}")"
                         Color="@Color"
                         OnClick="@(() => SelectTab(activeTab))">
                    <MudStack Row Spacing="2" AlignItems="AlignItems.Center" Justify="Justify.Center">
                        @if (!string.IsNullOrWhiteSpace(activeTab.Icon))
                        {
                            <MudIcon Icon="@activeTab.Icon" Color="@Color"/>
                        }
                        @activeTab.Name
                    </MudStack>
                </MudLink>
            }
            <MudMenu Icon="@Icons.Material.Filled.MoreVert"
                     Size="Size.Small"
                     Dense="true"
                     AnchorOrigin="Origin.BottomRight"
                     TransformOrigin="Origin.TopRight">
                @foreach (var tab in _tabs)
                {
                    <MudMenuItem Icon="@tab.Icon"
                                 OnClick="@(() => SelectTab(tab))"
                                 Disabled="@tab.IsActive">
                        @tab.Name
                    </MudMenuItem>
                }
            </MudMenu>
        }
        else
        {
            @* Normal mode: show all tabs *@
            @foreach (var tab in _tabs)
            {
                <MudLink Class="@($"flex-grow-1 rounded{(tab.IsActive ? $" {GetBackgroundClass(Color)}" : "")}")"
                         Color="@(tab.IsActive ? Color : Color.Default)"
                         OnClick="@(() => SelectTab(tab))">
                    <MudStack Row Spacing="2" AlignItems="AlignItems.Center" Justify="Justify.Center">
                        @if (!string.IsNullOrWhiteSpace(tab.Icon))
                        {
                            <MudIcon Icon="@tab.Icon"
                                     Color="@(tab.IsActive ? Color : Color.Default)"/>
                        }
                        @tab.Name
                    </MudStack>
                </MudLink>
            }
        }
        </MudStack>
    </div>

    <div class="mud-height-full mud-width-full px-4">
        @foreach (var tab in _tabs.Where(t => t.IsActive))
        {
            @tab.ChildContent
        }
    </div>
</MudStack>

@code {
    /// <summary>
    /// The content to render in the cascading tab content area
    /// </summary>
    [Parameter]
    public required RenderFragment ChildContent { get; set; }

    /// <summary>
    /// Color to display the tabs in
    /// </summary>
    [Parameter] public Color Color { get; set; } = Color.Primary;

    /// <summary>
    /// Width in pixels below which the tabs switch to compact mode with overflow menu
    /// </summary>
    [Parameter] public int CompactBreakpoint { get; set; } = 400;

    /// <summary>
    /// CSS class applied to the tab bar wrapper div
    /// </summary>
    [Parameter] public string WrapperClass { get; set; } = "mx-4";

    private List<Tab> _tabs = new();
    private ElementReference _tabBarRef;
    private bool _isCompactMode;
    private double _containerWidth;
    private bool _isObserving;

    /// <inheritdoc />
    protected override void OnInitialized()
    {
        _tabs.Clear();
    }

    /// <inheritdoc />
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && _tabs.Count > 0 && !_tabs.Any(t => t.IsActive))
        {
            _tabs[0].IsActive = true;
            StateHasChanged();
        }

        if (!_isObserving && _tabBarRef.Id != null)
        {
            _isObserving = true;
            ResizeObserver.OnResized += HandleResize;
            var initialSize = await ResizeObserver.Observe(_tabBarRef);
            if (initialSize != null)
            {
                _containerWidth = initialSize.Width;
                EvaluateCompactMode();
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    private void HandleResize(IDictionary<ElementReference, BoundingClientRect> changes)
    {
        if (_tabBarRef.Id != null && changes.TryGetValue(_tabBarRef, out var newSize))
        {
            if (Math.Abs(newSize.Width - _containerWidth) > 10)
            {
                _containerWidth = newSize.Width;
                EvaluateCompactMode();
                InvokeAsync(StateHasChanged).ContinueWith(t =>
                {
                    if (t.IsFaulted && t.Exception != null)
                    {
                        Console.Error.WriteLine($"Error in HandleResize: {t.Exception}");
                    }
                }, TaskScheduler.Default);
            }
        }
    }

    private void EvaluateCompactMode()
    {
        var shouldBeCompact = _containerWidth > 0 && _containerWidth < CompactBreakpoint;
        if (_isCompactMode != shouldBeCompact)
        {
            _isCompactMode = shouldBeCompact;
        }
    }

    /// <inheritdoc />
    public async ValueTask DisposeAsync()
    {
        ResizeObserver.OnResized -= HandleResize;
        if (_tabBarRef.Id != null)
        {
            await ResizeObserver.Unobserve(_tabBarRef);
        }
    }

    internal void AddTab(Tab tab)
    {
        if (!_tabs.Contains(tab))
        {
            _tabs.Add(tab);
            StateHasChanged();
        }
    }

    internal void RemoveTab(Tab tab)
    {
        if (_tabs.Contains(tab))
        {
            _tabs.Remove(tab);

            if (tab.IsActive && _tabs.Count > 0)
            {
                _tabs[0].IsActive = true;
            }

            StateHasChanged();
        }
    }

    /// <summary>
    /// Selects a tab to be active by its tab name
    /// </summary>
    /// <param name="tabName"></param>
    public void SelectTab(string tabName)
    {
        var tab = _tabs.FirstOrDefault(x => x.Name.Equals(tabName));
        
        if (tab == null) return;
        
        SelectTab(tab);
    }

    private void SelectTab(Tab tab)
    {
        foreach (var t in _tabs)
        {
            t.IsActive = t == tab;
        }

        StateHasChanged();
    }
    
    private string GetBorderClass(Color color)
    {
        return color switch
        {
            Color.Primary => "border-primary-1",
            Color.Secondary => "border-secondary-1",
            Color.Tertiary => "border-tertiary-1",
            Color.Info => "border-info-1",
            Color.Success => "border-success-1",
            Color.Warning => "border-warning-1",
            Color.Error => "border-error-1",
            _ => "border-primary-1"
        };
    }
    
    private string GetBackgroundClass(Color color)
    {
        return color switch
        {
            Color.Primary => "bg-primary-50",
            Color.Secondary => "bg-secondary-50",
            Color.Tertiary => "bg-tertiary-50",
            Color.Info => "bg-info-50",
            Color.Success => "bg-success-50",
            Color.Warning => "bg-warning-50",
            Color.Error => "bg-error-50",
            _ => "bg-primary-50"
        };
    }
}